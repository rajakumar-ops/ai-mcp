#!/usr/bin/env python3
"""
Web Penetration Testing MCP Server - Security tools for educational web testing
"""
import os
import sys
import logging
import subprocess
import re
from datetime import datetime, timezone
import httpx
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("web-pentest-server")

# Initialize MCP server - NO PROMPT PARAMETER!
mcp = FastMCP("web-pentest")

# Configuration
# Add any API keys, URLs, or configuration here
# No secrets needed for basic tools

# === UTILITY FUNCTIONS ===

def sanitize_input(input_str: str) -> str:
    """Sanitize input to prevent command injection."""
    # Remove potentially dangerous characters
    dangerous_chars = [';', '&', '|', '`', '$', '(', ')', '<', '>', '"', "'"]
    for char in dangerous_chars:
        input_str = input_str.replace(char, '')
    return input_str.strip()

def run_command(command: list, timeout: int = 60) -> str:
    """Run a command safely with timeout."""
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout,
            check=False
        )
        
        if result.returncode == 0:
            return f"‚úÖ Command executed successfully:\n{result.stdout}"
        else:
            return f"‚ö†Ô∏è Command completed with warnings:\n{result.stderr}\n\nOutput:\n{result.stdout}"
    except subprocess.TimeoutExpired:
        return "‚è±Ô∏è Command timed out after 60 seconds"
    except Exception as e:
        return f"‚ùå Error executing command: {str(e)}"

# === MCP TOOLS ===

@mcp.tool()
async def nmap_scan(target: str = "", scan_type: str = "basic") -> str:
    """Perform network port scanning using nmap."""
    if not target.strip():
        return "‚ùå Error: Target IP or hostname is required"
    
    target = sanitize_input(target)
    logger.info(f"Executing nmap scan on {target} with type {scan_type}")
    
    try:
        if scan_type == "basic":
            command = ["nmap", "-sS", "-O", "-sV", target]
        elif scan_type == "aggressive":
            command = ["nmap", "-A", "-sS", "-sU", "-T4", target]
        elif scan_type == "stealth":
            command = ["nmap", "-sS", "-f", "-T2", target]
        elif scan_type == "udp":
            command = ["nmap", "-sU", "--top-ports", "1000", target]
        else:
            command = ["nmap", "-sS", target]
        
        return run_command(command, timeout=120)
    except Exception as e:
        logger.error(f"Error in nmap_scan: {e}")
        return f"‚ùå Error: {str(e)}"

@mcp.tool()
async def nikto_scan(target: str = "", port: str = "80") -> str:
    """Perform web vulnerability scanning using nikto."""
    if not target.strip():
        return "‚ùå Error: Target URL is required"
    
    target = sanitize_input(target)
    port = sanitize_input(port)
    logger.info(f"Executing nikto scan on {target}:{port}")
    
    try:
        # Ensure target has protocol
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"
        
        command = ["nikto", "-h", target, "-p", port, "-Format", "txt"]
        return run_command(command, timeout=180)
    except Exception as e:
        logger.error(f"Error in nikto_scan: {e}")
        return f"‚ùå Error: {str(e)}"

@mcp.tool()
async def sqlmap_scan(target: str = "", data: str = "", cookie: str = "") -> str:
    """Perform SQL injection testing using sqlmap."""
    if not target.strip():
        return "‚ùå Error: Target URL is required"
    
    target = sanitize_input(target)
    data = sanitize_input(data)
    cookie = sanitize_input(cookie)
    logger.info(f"Executing sqlmap scan on {target}")
    
    try:
        command = ["sqlmap", "-u", target, "--batch", "--level=3", "--risk=2"]
        
        if data:
            command.extend(["--data", data])
        if cookie:
            command.extend(["--cookie", cookie])
        
        return run_command(command, timeout=300)
    except Exception as e:
        logger.error(f"Error in sqlmap_scan: {e}")
        return f"‚ùå Error: {str(e)}"

@mcp.tool()
async def wpscan_scan(target: str = "", username: str = "", password: str = "") -> str:
    """Perform WordPress security scanning using wpscan."""
    if not target.strip():
        return "‚ùå Error: Target WordPress URL is required"
    
    target = sanitize_input(target)
    username = sanitize_input(username)
    password = sanitize_input(password)
    logger.info(f"Executing wpscan on {target}")
    
    try:
        # Ensure target has protocol
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"
        
        command = ["ruby", "/opt/wpscan/wpscan.rb", "--url", target, "--format", "txt"]
        
        if username and password:
            command.extend(["--username", username, "--password", password])
        
        return run_command(command, timeout=240)
    except Exception as e:
        logger.error(f"Error in wpscan_scan: {e}")
        return f"‚ùå Error: {str(e)}"

@mcp.tool()
async def dirb_scan(target: str = "", wordlist: str = "common") -> str:
    """Perform directory brute force scanning using dirb."""
    if not target.strip():
        return "‚ùå Error: Target URL is required"
    
    target = sanitize_input(target)
    wordlist = sanitize_input(wordlist)
    logger.info(f"Executing dirb scan on {target}")
    
    try:
        # Ensure target has protocol
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"
        
        command = ["dirb", target]
        
        if wordlist == "big":
            command.extend(["-S", "-w", "/usr/share/dirb/wordlists/big.txt"])
        elif wordlist == "small":
            command.extend(["-S", "-w", "/usr/share/dirb/wordlists/small.txt"])
        else:
            command.append("-S")  # Silent mode
        
        return run_command(command, timeout=180)
    except Exception as e:
        logger.error(f"Error in dirb_scan: {e}")
        return f"‚ùå Error: {str(e)}"

@mcp.tool()
async def searchsploit_search(query: str = "", type_filter: str = "") -> str:
    """Search for exploits using searchsploit."""
    if not query.strip():
        return "‚ùå Error: Search query is required"
    
    query = sanitize_input(query)
    type_filter = sanitize_input(type_filter)
    logger.info(f"Executing searchsploit search for {query}")
    
    try:
        command = ["searchsploit", query]
        
        if type_filter:
            command.extend(["-t", type_filter])
        
        return run_command(command, timeout=60)
    except Exception as e:
        logger.error(f"Error in searchsploit_search: {e}")
        return f"‚ùå Error: {str(e)}"

@mcp.tool()
async def http_headers(target: str = "") -> str:
    """Check HTTP headers and basic web server information."""
    if not target.strip():
        return "‚ùå Error: Target URL is required"
    
    target = sanitize_input(target)
    logger.info(f"Checking HTTP headers for {target}")
    
    try:
        # Ensure target has protocol
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"
        
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(target)
            
            headers_info = "üåê HTTP Headers Analysis:\n\n"
            headers_info += f"Status Code: {response.status_code}\n"
            headers_info += f"Server: {response.headers.get('server', 'Not specified')}\n"
            headers_info += f"Content-Type: {response.headers.get('content-type', 'Not specified')}\n"
            headers_info += f"Content-Length: {response.headers.get('content-length', 'Not specified')}\n\n"
            
            headers_info += "Security Headers:\n"
            security_headers = [
                'x-frame-options', 'x-content-type-options', 'x-xss-protection',
                'strict-transport-security', 'content-security-policy', 'referrer-policy'
            ]
            
            for header in security_headers:
                value = response.headers.get(header, 'Not present')
                status = "‚úÖ" if value != "Not present" else "‚ùå"
                headers_info += f"{status} {header}: {value}\n"
            
            return headers_info
            
    except httpx.TimeoutException:
        return "‚è±Ô∏è Request timed out"
    except httpx.ConnectError:
        return "‚ùå Connection failed - check if target is reachable"
    except Exception as e:
        logger.error(f"Error in http_headers: {e}")
        return f"‚ùå Error: {str(e)}"

@mcp.tool()
async def ssl_info(target: str = "") -> str:
    """Check SSL/TLS certificate information."""
    if not target.strip():
        return "‚ùå Error: Target hostname is required"
    
    target = sanitize_input(target)
    logger.info(f"Checking SSL info for {target}")
    
    try:
        # Remove protocol if present
        if target.startswith(('http://', 'https://')):
            target = target.split('://')[1]
        
        command = ["openssl", "s_client", "-connect", f"{target}:443", "-servername", target]
        
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=10,
                input="\n"
            )
            
            if result.returncode == 0:
                # Parse certificate info
                cert_info = "üîí SSL Certificate Information:\n\n"
                
                # Extract certificate details using regex
                subject_match = re.search(r'subject=([^\n]+)', result.stdout)
                issuer_match = re.search(r'issuer=([^\n]+)', result.stdout)
                not_before_match = re.search(r'notBefore=([^\n]+)', result.stdout)
                not_after_match = re.search(r'notAfter=([^\n]+)', result.stdout)
                
                if subject_match:
                    cert_info += f"Subject: {subject_match.group(1)}\n"
                if issuer_match:
                    cert_info += f"Issuer: {issuer_match.group(1)}\n"
                if not_before_match:
                    cert_info += f"Valid From: {not_before_match.group(1)}\n"
                if not_after_match:
                    cert_info += f"Valid Until: {not_after_match.group(1)}\n"
                
                return cert_info
            else:
                return f"‚ùå SSL connection failed: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return "‚è±Ô∏è SSL connection timed out"
            
    except Exception as e:
        logger.error(f"Error in ssl_info: {e}")
        return f"‚ùå Error: {str(e)}"

# === SERVER STARTUP ===
if __name__ == "__main__":
    logger.info("Starting Web Penetration Testing MCP server...")
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)
